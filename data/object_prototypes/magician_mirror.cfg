{
id: "magician_mirror",
prototype: ["hittable"],

editor_info: { category: "Characters" },
solid_dimensions: ["~player","~enemy"],
collide_dimensions: ["~enemy"],

#make it so when the object runs into solid parts of the level, an on_collide_level event is fired so the shot can be destroyed.
object_level_collisions: true,
has_feet: false,

zorder: "@include data/zorder.cfg:player",

properties: {
	movespeed: "int :: 2",
	attack_damage: 1,	
	team: "'evil'",
	normal_alpha: 200,
	attack_cooldown: "int :: 100",
	
	flinch_threshold: 0,
	cycle_of_last_action: { type: 'int', default: 0 },
	hurt_velocity_y: "0",
	hurt_velocity_x: "0",
	
	# -- AI/player interactions -- #	
	offset_x: "16",
	offset_y: "16",
	align_self: "[
		add(me.midpoint_x,offset_x-me.midpoint_x%32),
		add(me.midpoint_y,offset_y-me.midpoint_y%32)]", // Tile size is 32
	align_self_x: "add(me.midpoint_x,offset_x-me.midpoint_x%32)",	
	align_self_y: "add(me.midpoint_y,offset_y-me.midpoint_y%32)",
	is_aligned: "bool :: bool(me.midpoint_x%32 = offset_x and me.midpoint_y%32 = offset_y)",
	
	old_midpoint_x: { type: "int", default: 0 },
	old_midpoint_y: { type: "int", default: 0 },
	old_midpoint_xy: { type: "[int]", default: [0,0] },
	
/*	is_player_behind: "bool :: if(
		facing_down, me.midpoint_y-level.player.midpoint_y > back_vision,
		facing_up, me.midpoint_y-level.player.midpoint_y < back_vision,
		facing_right, me.midpoint_x-level.player.midpoint_x > back_vision,
		facing_left, me.midpoint_x-level.player.midpoint_x < back_vision,
		true) where back_vision = 32", // Default if none of the others*/
	
	is_player_behind: "opposite_dir(dir_to_player)",
	
	opposite_dir: "def(string dir) -> string
		switch(dir,
			'down', 'up',
			'up',   'down',
			'right','left',
			'left', 'right',
			'down')",
	
	change_anim: "def(string anim) -> commands
		if(anim != animation, animation(anim))",

	is_vision_obstructed: "bool(solid(level, midpoint_x,midpoint_y,level.player.midpoint_x-midpoint_x,level.player.midpoint_y-midpoint_y))",
	is_player_visible: "bool :: not is_vision_obstructed and not is_player_behind",
	x_dist: "me.midpoint_x - level.player.midpoint_x",
	y_dist: "me.midpoint_y - level.player.midpoint_y",
	normal_dir_to_player: "string :: if(abs(x_dist) < abs(y_dist),
		if(x_dist < 0, 'right', 'left'),
		if(y_dist < 0, 'down', 'up'))",
	dir_to_player: "string :: if(abs(x_dist) > abs(y_dist),
		if(x_dist < 0, 'right', 'left'),
		if(y_dist < 0, 'down', 'up'))",
		
	normal_dir_from_player: "string :: if(abs(x_dist) < abs(y_dist),
		if(x_dist > 0, 'right', 'left'),
		if(y_dist > 0, 'down', 'up'))",
	dir_from_player: "string :: if(abs(x_dist) > abs(y_dist),
		if(x_dist > 0, 'right', 'left'),
		if(y_dist > 0, 'down', 'up'))",
	
	is_on_lens: "false",	// Placeholder
	
	is_lined_up_to_attack: "abs(x_dist) <= 32 or abs(y_dist) <= 32",
	cycle_of_last_attack: { type: 'int', default: 0 },
	is_attack_on_cooldown: "cycle - cycle_of_last_attack < attack_cooldown",
	
	begin_attack: "fire_event('attack')",
	// If we can actually see player, then walk towards player. Otherwise, try shortest route.
	track_player: "try_dir(dir_to_player)",
		//if(is_vision_obstructed, dir_to_player, normal_dir_to_player))",
	avoid_player: "if(solid_dir(normal_dir_from_player),
		try_dir(normal_dir_from_player),
		try_dir(dir_from_player))",
		
	cycle_of_last_sight: {type: 'int', default: 0},
	is_player_found: "bool :: cycle - cycle_of_last_sight < track_duration
		where track_duration = 200",
	
	avail_dir: "[string] :: if(
		facing_down,  ['left','right','down'],
		facing_up,    ['left','right','up'],
		facing_right, ['right','up','down'], 
		facing_left,  ['left','up','down'],
		['left','right','down'])", // Default if none of the others
		
		// Before we loop forever, check for a dead end!
	new_dir: "if(all_dirs_blocked, [any_new_dir,debug('dead_end')], _new_dir(1d3-1))
		where all_dirs_blocked = fold(map(avail_dir, solid_dir(value)), a and b)",
	_new_dir: "def(int rand) -> commands 
		if(solid_dir(avail_dir[rand]),
			new_dir, // Repeat until we get something valid
			change_anim('walk_'+avail_dir[rand]))",
	
	any_new_dir: "_any_new_dir(1d4-1)",
	_any_new_dir: "def(int rand) -> commands 
		if(solid_dir(any_dir[rand]),
			any_new_dir, // Repeat until we get something valid
			change_anim('walk_'+any_dir[rand]))
		where any_dir = ['left','right','down','up']",
	
	try_dir: "def(string dir) -> commands
		if(solid_dir(dir), new_dir, change_anim('walk_'+dir))",
	
},


on_create: "[animation('look_down'),
			set(facing, 1),	// No flipping! Must always face the same direction
			align_self,
			set(old_midpoint_x, midpoint_x),
			set(old_midpoint_y, midpoint_y),
			set(alpha, normal_alpha)]",
}
